<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Floss Matcher PoC</title>
    
    <style>
        :root {
            --bg: #f5f5f7;
            --card-bg: #ffffff;
            --border: #d0d0d5;
            --text-main: #222222;
            --text-muted: #666666;
            --accent: #2563eb;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 480px;
            margin: 0 auto;
            padding: 16px 12px 32px;
            background: var(--bg);
            color: var(--text-main);
        }

        h1 {
            font-size: 1.35rem;
            margin: 0 0 0.25rem;
            text-align: center;
        }

        p {
            font-size: 0.9rem;
            margin: 0 0 10px;
            text-align: center;
            color: var(--text-muted);
        }

        #fileInput {
            margin-top: 8px;
            width: 100%;
            font-size: 0.9rem;
        }

        /* Top controls (button + select) */
        .row {
            margin: 6px 0;
        }

        #canvasWrapper {
            margin-top: 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            display: block;
            overflow: hidden;
            background: var(--card-bg);
            box-shadow: 0 1px 4px rgba(15, 23, 42, 0.08);
            position: relative; /* NEW: needed for absolute overlay */
        }

        #sampleOverlay {
            position: absolute;
            border: 2px solid var(--accent);
            border-radius: 4px;
            pointer-events: none; /* so it doesn’t block taps */
            display: none;
            box-sizing: border-box;
            box-shadow: 0 0 4px rgba(0,0,0,0.25);
        }

        canvas {
            width: 100%;   /* full-width responsive */
            height: auto;
            display: block;
            cursor: crosshair;
        }

        #results {
            margin-top: 16px;
            padding: 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            box-shadow: 0 2px 6px rgba(15, 23, 42, 0.08);
        }

        .color-swatch {
            width: 42px;
            height: 42px;
            border-radius: 6px;
            border: 1px solid #ccc;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }

        #wbStatus {
            margin-top: 6px;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        button,
        select {
            font: inherit;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #ffffff;
            color: var(--text-main);
            outline: none;
        }

        button {
            cursor: pointer;
            transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.05s ease;
        }

        button:hover {
            background: #f3f4ff;
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.15);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: none;
        }

        /* Make white-ref button fill width on small screens */
        #setWhiteBtn {
            flex: 1 1 100%;
        }

        /* If you want the inline controls div to look nicer */
        /* (You already have inline styles; this just complements them) */
        div[style*="flex; flex-wrap"] {
            margin-top: 12px;
        }

        code {
            background: #eee;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .match-item {
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .match-swatch {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
            margin-right: 6px;
            vertical-align: middle;
        }

        .match-code {
            font-weight: 600;
        }

        .match-label {
            font-style: italic;
            opacity: 0.8;
            margin-left: 4px;
        }

        /* Make headings inside results stand out a bit */
        #results strong {
            font-size: 0.95rem;
        }

        /* Slightly scale things up on larger screens (desktop/tablet) */
        @media (min-width: 768px) {
            body {
                max-width: 700px;
                padding-top: 24px;
            }
            h1 {
                font-size: 1.5rem;
            }
            p {
                font-size: 0.95rem;
            }
        }
    </style>

</head>
<body>
    <h1>Floss Matcher PoC</h1>
    <div id="appVersion" style="text-align:center; font-size:0.75rem; color:#777; margin-top:2px;">
        v1.0.03
    </div>

    <p>
        1. Choose or take a photo of your threads.<br>
        2. (Optional) Select a white area for colour balance correction.<br>
        3. Tap on the image to sample a colour.<br>
        4. The app will show the nearest match of DMC threads.
    </p>

    <!-- On iPhone, this will let you either pick from Photos or use the camera -->
    <input type="file" id="fileInput" accept="image/*" capture="environment">

    <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
        <button id="setWhiteBtn">Tap image to set white reference</button>
        <label>
            Matches to show:
            <select id="matchCount">
                <option value="3">3</option>
                <option value="5" selected>5</option>
            </select>
        </label>
    </div>

    <div id="wbStatus" class="row" style="margin-top:6px; font-size:0.85rem; opacity:0.8;">
        No white reference set. For better accuracy, include a white/neutral card in your photo and set it as reference.
    </div>

    <div id="canvasWrapper">
        <canvas id="imageCanvas"></canvas>
        <div id="sampleOverlay"></div>
    </div>

    <div id="results" style="display:none;">
        <div class="row">
            <strong>Sampled colour:</strong>
        </div>
        <div class="row">
            <div id="sampleSwatch" class="color-swatch"></div>
            <span id="rgbText"></span>
        </div>

        <div class="row" style="margin-top:8px;">
            <strong>Closest floss matches:</strong>
        </div>
        <div class="row" id="bestMatch"></div>
        <div class="row" id="matchesList"></div>
    </div>


    <!-- Hidden image element used for loading -->
    <img id="hiddenImage" alt="" style="display:none;">

    <script>
        const APP_VERSION = "1.0.03";
        document.getElementById("appVersion").textContent = "v" + APP_VERSION;

        // Global palette (filled after JSON loads, with Lab precomputed)
        let FLOSS_COLORS = [];

        // White-balance calibration state
        let calibrationMode = false;
        let whiteRefLab = null;  // Lab of reference white/neutral

        const fileInput     = document.getElementById('fileInput');
        const hiddenImage   = document.getElementById('hiddenImage');
        const canvas        = document.getElementById('imageCanvas');
        const ctx           = canvas.getContext('2d');

        const resultsBox    = document.getElementById('results');
        const sampleSwatch  = document.getElementById('sampleSwatch');
        const rgbText       = document.getElementById('rgbText');
        const bestMatchDiv  = document.getElementById('bestMatch');
        const matchesList   = document.getElementById('matchesList');

        const setWhiteBtn   = document.getElementById('setWhiteBtn');
        const matchCountSel = document.getElementById('matchCount');
        const wbStatus      = document.getElementById('wbStatus');

        const sampleOverlay = document.getElementById('sampleOverlay');

        const SAMPLE_RADIUS = 10; // in canvas pixels (≈ 7x7 area)
        let previewActive = false;
        let previewCanvasX = 0;
        let previewCanvasY = 0;

        // --- 1. Load DMC palette from JSON and precompute Lab values ---
        fetch('dmc_palette.json?v=' + APP_VERSION)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Could not load dmc_palette.json');
                }
                return response.json();
            })
            .then(data => {
                FLOSS_COLORS = data.map(c => ({
                    ...c,
                    lab: rgbToLab(c.r, c.g, c.b)
                }));
                console.log('Loaded DMC colours:', FLOSS_COLORS.length);
            })
            .catch(err => {
                console.error(err);
                alert('Could not load DMC palette. Check that dmc_palette.json is in the same folder as index.html.');
            });

        // --- 2. White reference button ---
        setWhiteBtn.addEventListener('click', () => {
            if (!canvas.width || !canvas.height) {
                alert('Please load a photo first, then tap the white/neutral card in the image.');
                return;
            }
            calibrationMode = true;
            wbStatus.textContent = 'Calibration mode: tap a white/neutral card area in the image to set white reference.';
        });

        // --- 3. Handle file selection (photo or camera) ---
        fileInput.addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                hiddenImage.onload = function () {
                    drawImageToCanvas(hiddenImage);
                    // Reset calibration when a new image is loaded
                    calibrationMode = false;
                    whiteRefLab = null;
                    wbStatus.textContent = 'No white reference set. For better accuracy, include a white/neutral card in your photo and set it as reference.';
                };
                hiddenImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        function drawImageToCanvas(img) {
            const maxDisplayWidth = 500; // pixels
            let displayWidth = img.width;
            let displayHeight = img.height;

            if (displayWidth > maxDisplayWidth) {
                const scale = maxDisplayWidth / displayWidth;
                displayWidth = maxDisplayWidth;
                displayHeight = img.height * scale;
            }

            canvas.width = displayWidth;
            canvas.height = displayHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            resultsBox.style.display = 'none';
        }

        // Sample an average colour in a square area around (centerX, centerY)
        function sampleAverageRGB(centerX, centerY, radius) {
            const x0 = Math.max(0, centerX - radius);
            const y0 = Math.max(0, centerY - radius);
            const x1 = Math.min(canvas.width - 1, centerX + radius);
            const y1 = Math.min(canvas.height - 1, centerY + radius);

            const width  = x1 - x0 + 1;
            const height = y1 - y0 + 1;

            const imgData = ctx.getImageData(x0, y0, width, height).data;

            let sumR = 0, sumG = 0, sumB = 0;
            const numPixels = width * height;

            for (let i = 0; i < imgData.length; i += 4) {
                sumR += imgData[i];     // R
                sumG += imgData[i + 1]; // G
                sumB += imgData[i + 2]; // B
                // alpha (imgData[i + 3]) ignored
            }

            return {
                r: Math.round(sumR / numPixels),
                g: Math.round(sumG / numPixels),
                b: Math.round(sumB / numPixels)
            };
        }

        function updatePreviewAt(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();

            // Scale from CSS pixels to canvas pixels
            const scaleX = canvas.width  / rect.width;
            const scaleY = canvas.height / rect.height;

            const cx = (clientX - rect.left) * scaleX;
            const cy = (clientY - rect.top) * scaleY;

            previewCanvasX = Math.floor(cx);
            previewCanvasY = Math.floor(cy);

            // Size of sampling box in CSS pixels
            const boxWidthCss  = (2 * SAMPLE_RADIUS + 1) * (rect.width  / canvas.width);
            const boxHeightCss = (2 * SAMPLE_RADIUS + 1) * (rect.height / canvas.height);

            const leftCss = (clientX - rect.left) - boxWidthCss / 2;
            const topCss  = (clientY - rect.top)  - boxHeightCss / 2;

            sampleOverlay.style.width  = boxWidthCss + 'px';
            sampleOverlay.style.height = boxHeightCss + 'px';
            sampleOverlay.style.left   = leftCss + 'px';
            sampleOverlay.style.top    = topCss + 'px';
            sampleOverlay.style.display = 'block';
        }

        function handleSampleAtCurrentPreview() {
            const { r: rawR, g: rawG, b: rawB } = sampleAverageRGB(previewCanvasX, previewCanvasY, SAMPLE_RADIUS);

            // If we're in calibration mode, treat this tap as white reference
            if (calibrationMode) {
                calibrationMode = false;
                setWhiteReference(rawR, rawG, rawB);
                return;
            }

            if (!FLOSS_COLORS.length) {
                alert('DMC palette not loaded yet. Please wait a moment or refresh.');
                return;
            }

            showSampleAndMatches(rawR, rawG, rawB);
        }

        /* --- Mouse events (desktop) --- */
        canvas.addEventListener('mousedown', function (e) {
            if (!canvas.width || !canvas.height) return;
            previewActive = true;
            updatePreviewAt(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', function (e) {
            if (!previewActive) return;
            updatePreviewAt(e.clientX, e.clientY);
        });

        window.addEventListener('mouseup', function () {
            if (!previewActive) return;
            previewActive = false;
            sampleOverlay.style.display = 'none';
            handleSampleAtCurrentPreview();
        });

        /* --- Touch events (phone/tablet) --- */
        canvas.addEventListener('touchstart', function (e) {
            if (!canvas.width || !canvas.height) return;
            e.preventDefault();
            const t = e.touches[0];
            previewActive = true;
            updatePreviewAt(t.clientX, t.clientY);
        });

        canvas.addEventListener('touchmove', function (e) {
            if (!previewActive) return;
            e.preventDefault();
            const t = e.touches[0];
            updatePreviewAt(t.clientX, t.clientY);
        });

        canvas.addEventListener('touchend', function () {
            if (!previewActive) return;
            previewActive = false;
            sampleOverlay.style.display = 'none';
            handleSampleAtCurrentPreview();
        });

        canvas.addEventListener('touchcancel', function () {
            previewActive = false;
            sampleOverlay.style.display = 'none';
        });

        // --- 5. Set white reference in Lab space ---
        function setWhiteReference(r, g, b) {
            const lab = rgbToLab(r, g, b);

            // Lab L* is 0–100; avoid super dark areas as white references
            if (lab.L < 50) {
                alert('That area is too dark to be a white reference. Please choose a brighter white/neutral area.');
                wbStatus.textContent = 'White reference not set – chosen area was too dark.';
                return;
            }

            whiteRefLab = lab;
            const refHex = rgbToHex(r, g, b);
            wbStatus.innerHTML = `
                White reference set at RGB (${r}, ${g}, ${b}) | Hex ${refHex}.
                Matching will compensate for colour cast based on this reference.
            `;
        }

        // --- 6. Show sampled colour + top N closest DMC matches (ΔE2000) ---
        function showSampleAndMatches(r, g, b) {
            const hex = rgbToHex(r, g, b);
            // Display the raw camera colour (do NOT white-balance visually)
            sampleSwatch.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            rgbText.textContent = `RGB (image): (${r}, ${g}, ${b})  |  Hex: ${hex}`;

            const count = parseInt(matchCountSel.value, 10) || 5;

            // Convert sample to Lab, then optionally "neutralize" using white reference
            const sampleLabRaw = rgbToLab(r, g, b);
            let sampleLabForMatching = sampleLabRaw;

            if (whiteRefLab) {
                // Subtract the white reference's a/b to remove colour cast, keep lightness
                sampleLabForMatching = {
                    L: sampleLabRaw.L,
                    a: sampleLabRaw.a - whiteRefLab.a,
                    b: sampleLabRaw.b - whiteRefLab.b
                };
            }

            const topMatches = findClosestFlosses(sampleLabForMatching, count);

            if (!topMatches.length) {
                bestMatchDiv.textContent = 'No matches found.';
                matchesList.innerHTML = '';
                resultsBox.style.display = 'block';
                return;
            }

            const best = topMatches[0];
            const bestLabel = qualityLabel(best.distance);

            bestMatchDiv.innerHTML = `
                <div class="match-item">
                    <span class="match-swatch" style="background-color: rgb(${best.r}, ${best.g}, ${best.b});"></span>
                    <span class="match-code">${best.code} – ${best.name}</span><br>
                    <span>ΔE2000: ${best.distance.toFixed(2)} </span>
                    <span class="match-label">(${bestLabel})</span>
                </div>
            `;

            // Build list of remaining matches
            let listHtml = '';
            for (let i = 1; i < topMatches.length; i++) {
                const m = topMatches[i];
                const label = qualityLabel(m.distance);
                listHtml += `
                    <div class="match-item">
                        <span class="match-swatch" style="background-color: rgb(${m.r}, ${m.g}, ${m.b});"></span>
                        <span class="match-code">${m.code} – ${m.name}</span>
                        <span> | ΔE2000: ${m.distance.toFixed(2)}</span>
                        <span class="match-label"> (${label})</span>
                    </div>
                `;
            }
            matchesList.innerHTML = listHtml;

            resultsBox.style.display = 'block';
        }

        // --- 7. Find top N closest matches using Lab + ΔE2000 ---
        function findClosestFlosses(sampleLab, count) {
            const withDistances = FLOSS_COLORS.map(fl => ({
                ...fl,
                distance: deltaE2000(sampleLab, fl.lab)
            }));
            withDistances.sort((a, b) => a.distance - b.distance);
            return withDistances.slice(0, Math.min(count, withDistances.length));
        }

        // --- 8. Map ΔE2000 to a simple quality label ---
        function qualityLabel(dE) {
            if (dE < 1)   return 'Perfect / indistinguishable';
            if (dE < 2)   return 'Excellent match';
            if (dE < 5)   return 'Very good match';
            if (dE < 8)   return 'Good / usable match';
            if (dE < 15)  return 'Approximate match';
            return 'Rough / far off';
        }

        // --- 9. RGB -> Lab conversion helpers ---

        // Convert sRGB (0–255) to Lab (D65)
        function rgbToLab(r, g, b) {
            // 1) Normalize to 0–1
            let R = r / 255;
            let G = g / 255;
            let B = b / 255;

            // 2) Linearize sRGB
            R = R <= 0.04045 ? R / 12.92 : Math.pow((R + 0.055) / 1.055, 2.4);
            G = G <= 0.04045 ? G / 12.92 : Math.pow((G + 0.055) / 1.055, 2.4);
            B = B <= 0.04045 ? B / 12.92 : Math.pow((B + 0.055) / 1.055, 2.4);

            // 3) Convert to XYZ (Observer = 2°, Illuminant = D65)
            let X = R * 0.4124 + G * 0.3576 + B * 0.1805;
            let Y = R * 0.2126 + G * 0.7152 + B * 0.0722;
            let Z = R * 0.0193 + G * 0.1192 + B * 0.9505;

            // Reference white D65
            const refX = 0.95047;
            const refY = 1.00000;
            const refZ = 1.08883;

            X /= refX;
            Y /= refY;
            Z /= refZ;

            // 4) XYZ to Lab
            X = xyzToLabHelper(X);
            Y = xyzToLabHelper(Y);
            Z = xyzToLabHelper(Z);

            const L = 116 * Y - 16;
            const a = 500 * (X - Y);
            const bVal = 200 * (Y - Z);

            return { L, a, b: bVal };
        }

        function xyzToLabHelper(t) {
            const delta = 6 / 29;
            return t > Math.pow(delta, 3)
                ? Math.cbrt(t)
                : (t / (3 * Math.pow(delta, 2))) + (4 / 29);
        }

        // --- 10. ΔE2000 implementation ---
        function deltaE2000(lab1, lab2) {
            const L1 = lab1.L;
            const a1 = lab1.a;
            const b1 = lab1.b;
            const L2 = lab2.L;
            const a2 = lab2.a;
            const b2 = lab2.b;

            const kL = 1;
            const kC = 1;
            const kH = 1;

            const C1 = Math.sqrt(a1 * a1 + b1 * b1);
            const C2 = Math.sqrt(a2 * a2 + b2 * b2);
            const Cbar = (C1 + C2) / 2.0;

            const Cbar7 = Math.pow(Cbar, 7);
            const G = 0.5 * (1 - Math.sqrt(Cbar7 / (Cbar7 + Math.pow(25, 7))));

            const a1Prime = (1 + G) * a1;
            const a2Prime = (1 + G) * a2;

            const C1Prime = Math.sqrt(a1Prime * a1Prime + b1 * b1);
            const C2Prime = Math.sqrt(a2Prime * a2Prime + b2 * b2);
            const CbarPrime = (C1Prime + C2Prime) / 2.0;

            const h1Prime = calcHuePrime(b1, a1Prime);
            const h2Prime = calcHuePrime(b2, a2Prime);

            let deltahPrime;
            const diffh = h2Prime - h1Prime;
            if (C1Prime * C2Prime === 0) {
                deltahPrime = 0;
            } else if (Math.abs(diffh) <= 180) {
                deltahPrime = diffh;
            } else if (diffh > 180) {
                deltahPrime = diffh - 360;
            } else {
                deltahPrime = diffh + 360;
            }

            const deltaLPrime = L2 - L1;
            const deltaCPrime = C2Prime - C1Prime;
            const deltaHPrime = 2 * Math.sqrt(C1Prime * C2Prime) * Math.sin(deg2rad(deltahPrime / 2));

            let HbarPrime;
            if (C1Prime * C2Prime === 0) {
                HbarPrime = h1Prime + h2Prime;
            } else if (Math.abs(h1Prime - h2Prime) <= 180) {
                HbarPrime = (h1Prime + h2Prime) / 2;
            } else if ((h1Prime + h2Prime) < 360) {
                HbarPrime = (h1Prime + h2Prime + 360) / 2;
            } else {
                HbarPrime = (h1Prime + h2Prime - 360) / 2;
            }

            const T =
                1 -
                0.17 * Math.cos(deg2rad(HbarPrime - 30)) +
                0.24 * Math.cos(deg2rad(2 * HbarPrime)) +
                0.32 * Math.cos(deg2rad(3 * HbarPrime + 6)) -
                0.20 * Math.cos(deg2rad(4 * HbarPrime - 63));

            const deltaTheta =
                30 * Math.exp(-((HbarPrime - 275) / 25) * ((HbarPrime - 275) / 25));
            const R_C = 2 * Math.sqrt(Math.pow(CbarPrime, 7) / (Math.pow(CbarPrime, 7) + Math.pow(25, 7)));
            const Lbar = (L1 + L2) / 2;
            const S_L = 1 + ((0.015 * (Lbar - 50) * (Lbar - 50)) / Math.sqrt(20 + (Lbar - 50) * (Lbar - 50)));
            const S_C = 1 + 0.045 * CbarPrime;
            const S_H = 1 + 0.015 * CbarPrime * T;
            const R_T = -Math.sin(deg2rad(2 * deltaTheta)) * R_C;

            const dE = Math.sqrt(
                Math.pow(deltaLPrime / (kL * S_L), 2) +
                Math.pow(deltaCPrime / (kC * S_C), 2) +
                Math.pow(deltaHPrime / (kH * S_H), 2) +
                R_T * (deltaCPrime / (kC * S_C)) * (deltaHPrime / (kH * S_H))
            );

            return dE;
        }

        function calcHuePrime(b, aPrime) {
            if (aPrime === 0 && b === 0) return 0;
            const hue = rad2deg(Math.atan2(b, aPrime));
            return hue >= 0 ? hue : hue + 360;
        }

        function deg2rad(deg) {
            return (deg * Math.PI) / 180;
        }

        function rad2deg(rad) {
            return (rad * 180) / Math.PI;
        }

        // --- 11. Utility: RGB → Hex string ---
        function rgbToHex(r, g, b) {
            return "#" + [r, g, b].map(function (x) {
                const hex = x.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join("");
        }
    </script>

</body>
</html>
