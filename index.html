<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Floss Matcher PoC</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 0 10px;
        }
        h1 {
            font-size: 1.4rem;
            margin-bottom: 0.5rem;
        }
        #canvasWrapper {
            margin-top: 10px;
            border: 1px solid #ccc;
            display: inline-block;
        }
        canvas {
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        #results {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #fafafa;
        }
        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 4px;
            border: 1px solid #ccc;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }
        .row {
            margin: 6px 0;
        }
        code {
            background: #eee;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .match-item {
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .match-swatch {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
            margin-right: 6px;
            vertical-align: middle;
        }

        .match-code {
            font-weight: 600;
        }

        .match-label {
            font-style: italic;
            opacity: 0.8;
        }

    </style>
</head>
<body>
    <h1>Floss Matcher PoC</h1>
    <p>
        1. Choose or take a photo of your threads.<br>
        2. Tap on the image to sample a colour.<br>
        3. The app will show the nearest match from a tiny demo palette.
    </p>

    <!-- On iPhone, this will let you either pick from Photos or use the camera -->
    <input type="file" id="fileInput" accept="image/*" capture="environment">

    <div id="canvasWrapper">
        <canvas id="imageCanvas"></canvas>
    </div>

    <div id="results" style="display:none;">
        <div class="row">
            <strong>Closest floss matches:</strong>
        </div>
        <div class="row" id="bestMatch"></div>
        <div class="row" id="matchesList"></div>
    </div>

    <!-- Hidden image element used for loading -->
    <img id="hiddenImage" alt="" style="display:none;">

    <script>
        // Global palette (filled after JSON loads, with Lab precomputed)
        let FLOSS_COLORS = [];

        const fileInput   = document.getElementById('fileInput');
        const hiddenImage = document.getElementById('hiddenImage');
        const canvas      = document.getElementById('imageCanvas');
        const ctx         = canvas.getContext('2d');

        const resultsBox   = document.getElementById('results');
        const sampleSwatch = document.getElementById('sampleSwatch');
        const rgbText      = document.getElementById('rgbText');
        const bestMatchDiv = document.getElementById('bestMatch');
        const matchesList  = document.getElementById('matchesList');

        // --- 1. Load DMC palette from JSON and precompute Lab values ---
        fetch('dmc_palette.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Could not load dmc_palette.json');
                }
                return response.json();
            })
            .then(data => {
                FLOSS_COLORS = data.map(c => ({
                    ...c,
                    lab: rgbToLab(c.r, c.g, c.b)
                }));
                console.log('Loaded DMC colours:', FLOSS_COLORS.length);
            })
            .catch(err => {
                console.error(err);
                alert('Could not load DMC palette. Check that dmc_palette.json is in the same folder as index.html.');
            });

        // --- 2. Handle file selection (photo or camera) ---
        fileInput.addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                hiddenImage.onload = function () {
                    drawImageToCanvas(hiddenImage);
                };
                hiddenImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        function drawImageToCanvas(img) {
            const maxDisplayWidth = 500; // pixels
            let displayWidth = img.width;
            let displayHeight = img.height;

            if (displayWidth > maxDisplayWidth) {
                const scale = maxDisplayWidth / displayWidth;
                displayWidth = maxDisplayWidth;
                displayHeight = img.height * scale;
            }

            canvas.width = displayWidth;
            canvas.height = displayHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            resultsBox.style.display = 'none';
        }

        // --- 3. When user taps/clicks the canvas, sample that pixel ---
        canvas.addEventListener('click', function (e) {
            if (!canvas.width || !canvas.height) return;

            if (!FLOSS_COLORS.length) {
                alert('DMC palette not loaded yet. Please wait a moment or refresh.');
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor(e.clientX - rect.left);
            const y = Math.floor(e.clientY - rect.top);

            const pixel = ctx.getImageData(x, y, 1, 1).data;
            const r = pixel[0];
            const g = pixel[1];
            const b = pixel[2];

            showSampleAndMatches(r, g, b);
        });

        // --- 4. Show sampled colour + top N closest DMC matches (ΔE2000) ---
        function showSampleAndMatches(r, g, b) {
            const hex = rgbToHex(r, g, b);
            sampleSwatch.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            rgbText.textContent = `RGB: (${r}, ${g}, ${b})  |  Hex: ${hex}`;

            const topMatches = findClosestFlosses(r, g, b, 5); // top 5 (or fewer if you prefer)

            if (!topMatches.length) {
                bestMatchDiv.textContent = 'No matches found.';
                matchesList.innerHTML = '';
                resultsBox.style.display = 'block';
                return;
            }

            const best = topMatches[0];
            const bestLabel = qualityLabel(best.distance);

            bestMatchDiv.innerHTML = `
                <div class="match-item">
                    <span class="match-swatch" style="background-color: rgb(${best.r}, ${best.g}, ${best.b});"></span>
                    <span class="match-code">${best.code} – ${best.name}</span><br>
                    <span>ΔE2000: ${best.distance.toFixed(2)} </span>
                    <span class="match-label">(${bestLabel})</span>
                </div>
            `;

            // Build list of remaining matches (2nd–5th)
            let listHtml = '';
            for (let i = 1; i < topMatches.length; i++) {
                const m = topMatches[i];
                const label = qualityLabel(m.distance);
                listHtml += `
                    <div class="match-item">
                        <span class="match-swatch" style="background-color: rgb(${m.r}, ${m.g}, ${m.b});"></span>
                        <span class="match-code">${m.code} – ${m.name}</span>
                        <span> | ΔE2000: ${m.distance.toFixed(2)}</span>
                        <span class="match-label"> (${label})</span>
                    </div>
                `;
            }
            matchesList.innerHTML = listHtml;

            resultsBox.style.display = 'block';
        }

        // --- 5. Find top N closest matches using Lab + ΔE2000 ---
        function findClosestFlosses(r, g, b, count) {
            const sampleLab = rgbToLab(r, g, b);
            const withDistances = FLOSS_COLORS.map(fl => ({
                ...fl,
                distance: deltaE2000(sampleLab, fl.lab)
            }));
            withDistances.sort((a, b) => a.distance - b.distance);
            return withDistances.slice(0, Math.min(count, withDistances.length));
        }

        // --- 6. Map ΔE2000 to a simple quality label ---
        function qualityLabel(dE) {
            if (dE < 1)   return 'Perfect / indistinguishable';
            if (dE < 2)   return 'Excellent match';
            if (dE < 5)   return 'Very good match';
            if (dE < 8)   return 'Good / usable match';
            if (dE < 15)  return 'Approximate match';
            return 'Rough / far off';
        }

        // --- 7. RGB -> Lab conversion helpers ---

        // Convert sRGB (0–255) to Lab (D65)
        function rgbToLab(r, g, b) {
            // 1) Normalize to 0–1
            let R = r / 255;
            let G = g / 255;
            let B = b / 255;

            // 2) Linearize sRGB
            R = R <= 0.04045 ? R / 12.92 : Math.pow((R + 0.055) / 1.055, 2.4);
            G = G <= 0.04045 ? G / 12.92 : Math.pow((G + 0.055) / 1.055, 2.4);
            B = B <= 0.04045 ? B / 12.92 : Math.pow((B + 0.055) / 1.055, 2.4);

            // 3) Convert to XYZ (Observer = 2°, Illuminant = D65)
            let X = R * 0.4124 + G * 0.3576 + B * 0.1805;
            let Y = R * 0.2126 + G * 0.7152 + B * 0.0722;
            let Z = R * 0.0193 + G * 0.1192 + B * 0.9505;

            // Reference white D65
            const refX = 0.95047;
            const refY = 1.00000;
            const refZ = 1.08883;

            X /= refX;
            Y /= refY;
            Z /= refZ;

            // 4) XYZ to Lab
            X = xyzToLabHelper(X);
            Y = xyzToLabHelper(Y);
            Z = xyzToLabHelper(Z);

            const L = 116 * Y - 16;
            const a = 500 * (X - Y);
            const bVal = 200 * (Y - Z);

            return { L, a, b: bVal };
        }

        function xyzToLabHelper(t) {
            const delta = 6 / 29;
            return t > Math.pow(delta, 3)
                ? Math.cbrt(t)
                : (t / (3 * Math.pow(delta, 2))) + (4 / 29);
        }

        // --- 8. ΔE2000 implementation ---
        function deltaE2000(lab1, lab2) {
            const L1 = lab1.L;
            const a1 = lab1.a;
            const b1 = lab1.b;
            const L2 = lab2.L;
            const a2 = lab2.a;
            const b2 = lab2.b;

            const kL = 1;
            const kC = 1;
            const kH = 1;

            const C1 = Math.sqrt(a1 * a1 + b1 * b1);
            const C2 = Math.sqrt(a2 * a2 + b2 * b2);
            const Cbar = (C1 + C2) / 2.0;

            const Cbar7 = Math.pow(Cbar, 7);
            const G = 0.5 * (1 - Math.sqrt(Cbar7 / (Cbar7 + Math.pow(25, 7))));

            const a1Prime = (1 + G) * a1;
            const a2Prime = (1 + G) * a2;

            const C1Prime = Math.sqrt(a1Prime * a1Prime + b1 * b1);
            const C2Prime = Math.sqrt(a2Prime * a2Prime + b2 * b2);
            const CbarPrime = (C1Prime + C2Prime) / 2.0;

            const h1Prime = calcHuePrime(b1, a1Prime);
            const h2Prime = calcHuePrime(b2, a2Prime);

            let deltahPrime;
            const diffh = h2Prime - h1Prime;
            if (C1Prime * C2Prime === 0) {
                deltahPrime = 0;
            } else if (Math.abs(diffh) <= 180) {
                deltahPrime = diffh;
            } else if (diffh > 180) {
                deltahPrime = diffh - 360;
            } else {
                deltahPrime = diffh + 360;
            }

            const deltaLPrime = L2 - L1;
            const deltaCPrime = C2Prime - C1Prime;
            const deltaHPrime = 2 * Math.sqrt(C1Prime * C2Prime) * Math.sin(deg2rad(deltahPrime / 2));

            let HbarPrime;
            if (C1Prime * C2Prime === 0) {
                HbarPrime = h1Prime + h2Prime;
            } else if (Math.abs(h1Prime - h2Prime) <= 180) {
                HbarPrime = (h1Prime + h2Prime) / 2;
            } else if ((h1Prime + h2Prime) < 360) {
                HbarPrime = (h1Prime + h2Prime + 360) / 2;
            } else {
                HbarPrime = (h1Prime + h2Prime - 360) / 2;
            }

            const T =
                1 -
                0.17 * Math.cos(deg2rad(HbarPrime - 30)) +
                0.24 * Math.cos(deg2rad(2 * HbarPrime)) +
                0.32 * Math.cos(deg2rad(3 * HbarPrime + 6)) -
                0.20 * Math.cos(deg2rad(4 * HbarPrime - 63));

            const deltaTheta =
                30 * Math.exp(-((HbarPrime - 275) / 25) * ((HbarPrime - 275) / 25));
            const R_C = 2 * Math.sqrt(Math.pow(CbarPrime, 7) / (Math.pow(CbarPrime, 7) + Math.pow(25, 7)));
            const S_L = 1 + ((0.015 * (L1 + L2) / 2 - 50) * (0.015 * (L1 + L2) / 2 - 50)) /
                        Math.sqrt(20 + ((0.015 * (L1 + L2) / 2 - 50) * (0.015 * (L1 + L2) / 2 - 50)));
            const S_C = 1 + 0.045 * CbarPrime;
            const S_H = 1 + 0.015 * CbarPrime * T;
            const R_T = -Math.sin(deg2rad(2 * deltaTheta)) * R_C;

            const dE = Math.sqrt(
                Math.pow(deltaLPrime / (kL * S_L), 2) +
                Math.pow(deltaCPrime / (kC * S_C), 2) +
                Math.pow(deltaHPrime / (kH * S_H), 2) +
                R_T * (deltaCPrime / (kC * S_C)) * (deltaHPrime / (kH * S_H))
            );

            return dE;
        }

        function calcHuePrime(b, aPrime) {
            if (aPrime === 0 && b === 0) return 0;
            const hue = rad2deg(Math.atan2(b, aPrime));
            return hue >= 0 ? hue : hue + 360;
        }

        function deg2rad(deg) {
            return (deg * Math.PI) / 180;
        }

        function rad2deg(rad) {
            return (rad * 180) / Math.PI;
        }

        // --- 9. Utility: RGB → Hex string ---
        function rgbToHex(r, g, b) {
            return "#" + [r, g, b].map(function (x) {
                const hex = x.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join("");
        }
    </script>



</body>
</html>
