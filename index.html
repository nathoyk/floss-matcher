<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Floss Matcher</title>
    
    <style>
        :root {
            --bg: #f5f5f7;
            --card-bg: #ffffff;
            --border: #d0d0d5;
            --text-main: #222222;
            --text-muted: #666666;
            --accent: #2563eb;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 480px;
            margin: 0 auto;
            padding: 16px 12px 32px;
            background: var(--bg);
            color: var(--text-main);
        }

        h1 {
            font-size: 1.35rem;
            margin: 0 0 0.25rem;
            text-align: center;
        }

        p {
            font-size: 0.9rem;
            margin: 0 0 10px;
            text-align: center;
            color: var(--text-muted);
        }

        /* Generic rows */
        .row {
            margin: 6px 0;
        }

        #canvasWrapper {
            margin-top: 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            display: block;
            overflow: hidden;
            background: var(--card-bg);
            box-shadow: 0 1px 4px rgba(15, 23, 42, 0.08);
            position: relative;
        }

        #sampleOverlay {
            position: absolute;
            border: 2px solid var(--accent);
            border-radius: 4px;
            pointer-events: none;
            display: none;
            box-sizing: border-box;
            box-shadow: 0 0 4px rgba(0,0,0,0.25);
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            cursor: crosshair;
        }

        #results {
            margin-top: 16px;
            padding: 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--card-bg);
            box-shadow: 0 2px 6px rgba(15, 23, 42, 0.08);
        }

        .color-swatch {
            width: 42px;
            height: 42px;
            border-radius: 6px;
            border: 1px solid #ccc;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }

        #wbStatus {
            margin-top: 6px;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        button,
        select {
            font: inherit;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #ffffff;
            color: var(--text-main);
            outline: none;
        }

        .primaryButton {
            width: 100%;
            margin-top: 10px;
            background: var(--accent);
            color: #ffffff;
            border-color: var(--accent);
            font-weight: 600;
            text-align: center;
        }

        .primaryButton:hover {
            background: #1d4ed8;
            border-color: #1d4ed8;
        }

        .primaryButton:active {
            background: #1e40af;
        }

        button {
            cursor: pointer;
            transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.05s ease;
        }

        button:hover {
            background: #f3f4ff;
            box-shadow: 0 1px 3px rgba(15, 23, 42, 0.15);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: none;
        }

        #setWhiteBtn {
            flex: 1 1 100%;
        }

        .iconButton {
            border: none;
            background: transparent;
            padding: 0 4px;
            cursor: pointer;
            font-size: 0.9rem;
            color: #888;
        }

        .iconButton:hover {
            color: #dc2626;
            transform: translateY(1px);
        }

        div[style*="flex; flex-wrap"] {
            margin-top: 12px;
        }

        code {
            background: #eee;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .match-item {
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .match-swatch {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ccc;
            margin-right: 6px;
            vertical-align: middle;
        }

        .match-code {
            font-weight: 600;
        }

        .match-label {
            font-style: italic;
            opacity: 0.8;
            margin-left: 4px;
        }

        #results strong {
            font-size: 0.95rem;
        }

        .name-warning {
            color: #dc2626;
            font-weight: 600;
            cursor: pointer;
        }

        /* Tabs */
        .tabButton {
            padding: 6px 12px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #ffffff;
            font-size: 0.85rem;
        }

        .tab-active {
            background: var(--accent);
            color: #ffffff;
            border-color: var(--accent);
        }

        @media (min-width: 768px) {
            body {
                max-width: 700px;
                padding-top: 24px;
            }
            h1 {
                font-size: 1.5rem;
            }
            p {
                font-size: 0.95rem;
            }
        }
    </style>
</head>
<body>
    <h1>Floss Matcher</h1>
    <div id="appVersion" style="text-align:center; font-size:0.75rem; color:#777; margin-top:2px;">
        v0.3.0
    </div>

    <div style="margin-top:8px; display:flex; gap:8px; justify-content:center; font-size:0.85rem;">
        <button id="tabMatcher"   type="button" class="tabButton tab-active">Matcher</button>
        <button id="tabReference" type="button" class="tabButton">DMC Reference</button>
    </div>

    <!-- MATCHER PAGE -->
    <div id="matcherPage">
        <p>
            1. Choose or take a photo of your threads.<br>
            2. Calibrate with your grey / white / black cards (optional but recommended).<br>
            3. Tap on the image to sample a colour.<br>
            4. The app will show the nearest match of DMC threads.
        </p>

        <input type="file" id="fileInput" accept="image/*" capture="environment" style="display:none;">

        <button id="fileButton" type="button" class="primaryButton">
            üì∑ Take or choose photo
        </button>

        <div style="margin-top:10px; display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
            <button id="setWhiteBtn">Quick white ref (optional)</button>
            <label>
                Matches to show:
                <select id="matchCount">
                    <option value="3">3</option>
                    <option value="5" selected>5</option>
                </select>
            </label>
        </div>

        <div id="wbStatus" class="row" style="margin-top:6px; font-size:0.85rem; opacity:0.8;">
            No white reference set. For better accuracy, include a white/neutral card in your photo and set it as reference.
        </div>

        <!-- 3-card calibration panel -->
        <div id="calibrationPanel" style="margin-top:12px; font-size:0.85rem;">
            <strong>Calibration (3-card)</strong>
            <div id="calibrationStatus" style="margin-top:4px; color:#666;">
                Not calibrated. When your reference cards arrive, tap ‚ÄúStart calibration‚Äù.
            </div>
            <button id="startCalibBtn" type="button" style="margin-top:6px; font-size:0.8rem;">
                Start calibration (grey ‚Üí white ‚Üí black)
            </button>
            <button id="resetCalibBtn" type="button" style="margin-top:6px; margin-left:4px; font-size:0.8rem;">
                Reset
            </button>
        </div>

        <div id="canvasWrapper">
            <canvas id="imageCanvas"></canvas>
            <div id="sampleOverlay"></div>
        </div>

        <div id="results" style="display:none;">
            <div class="row">
                <strong>Sampled colour:</strong>
            </div>
            <div class="row">
                <div id="sampleSwatch" class="color-swatch"></div>
                <span id="rgbText"></span>
            </div>

            <div class="row" style="margin-top:8px;">
                <strong>Closest floss matches:</strong>
            </div>
            <div class="row" id="bestMatch"></div>
            <div class="row" id="matchesList"></div>
        </div>

        <hr style="margin:16px 0; border:none; border-top:1px solid #ddd;">

        <section id="packSection">
            <h2 style="font-size:1rem; margin-bottom:4px;">Saved pack mappings</h2>
            <div class="row" id="packSaveRow">
                <div style="font-size:0.85rem; margin-bottom:4px;">
                    Save the current best match as one of your generic pack colours.
                </div>
                <div style="display:flex; flex-wrap:wrap; gap:6px; margin-bottom:6px;">
                    <input id="packNameInput" type="text" placeholder="Pack name (e.g. Pack A)" style="flex:1 1 130px; min-width:0; padding:6px 8px; font-size:0.85rem;">
                    <input id="packSlotInput" type="text" placeholder="Slot (e.g. 1, A1)" style="flex:1 1 80px; min-width:0; padding:6px 8px; font-size:0.85rem;">
                </div>
                <button id="saveMappingBtn" type="button" style="font-size:0.85rem;">Save current best match</button>
                <div id="saveMappingStatus" style="margin-top:4px; font-size:0.8rem; color:#666;"></div>
            </div>
            <div id="mappingsList" style="margin-top:8px; font-size:0.85rem;"></div>
        </section>

        <section id="inventorySection" style="margin-top:18px;">
            <h2 style="font-size:1rem; margin-bottom:4px;">Inventory</h2>
            <div class="row">
                <div style="display:flex; flex-wrap:wrap; gap:6px; margin-bottom:6px;">
                    <input id="invBrandInput" type="text" placeholder="Brand (e.g. DMC)" style="flex:1 1 90px; min-width:0; padding:6px 8px; font-size:0.85rem;">
                    <input id="invCodeInput" type="text" placeholder="Code (e.g. 310)" style="flex:1 1 80px; min-width:0; padding:6px 8px; font-size:0.85rem;">
                    <input id="invNameInput" type="text" placeholder="Name (optional)" style="flex:1 1 130px; min-width:0; padding:6px 8px; font-size:0.85rem;">
                    <input id="invQtyInput" type="number" min="0" placeholder="Qty" style="flex:0 0 70px; padding:6px 8px; font-size:0.85rem;">
                </div>
                <button id="addInventoryBtn" type="button" style="font-size:0.85rem;">Add to inventory</button>
                <div id="inventoryStatus" style="margin-top:4px; font-size:0.8rem; color:#666;"></div>
            </div>
            <div id="inventoryList" style="margin-top:8px; font-size:0.85rem;"></div>
        </section>

        <div id="nameHintBox" 
            style="display:none; margin-top:10px; padding:10px; 
                    border:1px solid #dc2626; border-radius:8px; 
                    background:#fee2e2; color:#7f1d1d; font-size:0.85rem;">
            <strong>No match found for this code.</strong><br><br>
            ‚Ä¢ This code does not exist in the DMC database, OR<br>
            ‚Ä¢ The code is correct but not part of the floss set you loaded.<br><br>
            You may enter the thread name manually if you know it.
        </div>
    </div>

    <!-- DMC REFERENCE PAGE -->
    <div id="referencePage" style="display:none; margin-top:12px;">
        <div id="dmcRefStatus" style="font-size:0.8rem; color:#666; margin-bottom:6px;">
            Loading DMC palette...
        </div>
        <div id="dmcRefList"
             style="max-height:60vh; overflow-y:auto; border-radius:10px;
                    border:1px solid var(--border); background:#ffffff; padding:8px;">
        </div>
    </div>

    <!-- Hidden image element used for loading -->
    <img id="hiddenImage" alt="" style="display:none;">

    <script>
        const APP_VERSION = "0.3.0";
        document.getElementById("appVersion").textContent = "v" + APP_VERSION;

        // Global palette
        let FLOSS_COLORS = [];

        // Old single white-ref state (optional)
        let calibrationMode = false;
        let whiteRefLab = null;

        // 3-card calibration state
        let calibPhase = null; // null | 'grey' | 'white' | 'black'
        let calibMeasured = {
            grey:  null,
            white: null,
            black: null
        };
        let calibReady = false;

        // Targets from your reference card manufacturer
        const CARD_TARGETS = {
            grey:  { r: 162, g: 162, b: 160 },
            white: { r: 220, g: 224, b: 223 },
            black: { r: 16,  g: 16,  b: 15 }
        };

        const fileInput     = document.getElementById('fileInput');
        const hiddenImage   = document.getElementById('hiddenImage');
        const canvas        = document.getElementById('imageCanvas');
        const ctx           = canvas.getContext('2d');

        const resultsBox    = document.getElementById('results');
        const sampleSwatch  = document.getElementById('sampleSwatch');
        const rgbText       = document.getElementById('rgbText');
        const bestMatchDiv  = document.getElementById('bestMatch');
        const matchesList   = document.getElementById('matchesList');

        const setWhiteBtn   = document.getElementById('setWhiteBtn');
        const matchCountSel = document.getElementById('matchCount');
        const wbStatus      = document.getElementById('wbStatus');

        const sampleOverlay = document.getElementById('sampleOverlay');
        const fileButton    = document.getElementById('fileButton');

        const calibrationStatus = document.getElementById('calibrationStatus');
        const startCalibBtn      = document.getElementById('startCalibBtn');
        const resetCalibBtn      = document.getElementById('resetCalibBtn');

        // Pack mapping & inventory elements
        const packNameInput      = document.getElementById('packNameInput');
        const packSlotInput      = document.getElementById('packSlotInput');
        const saveMappingBtn     = document.getElementById('saveMappingBtn');
        const saveMappingStatus  = document.getElementById('saveMappingStatus');
        const mappingsList       = document.getElementById('mappingsList');

        const invBrandInput      = document.getElementById('invBrandInput');
        const invCodeInput       = document.getElementById('invCodeInput');
        const invNameInput       = document.getElementById('invNameInput');
        const invQtyInput        = document.getElementById('invQtyInput');
        const addInventoryBtn    = document.getElementById('addInventoryBtn');
        const inventoryStatus    = document.getElementById('inventoryStatus');
        const inventoryList      = document.getElementById('inventoryList');

        const nameHintBox        = document.getElementById('nameHintBox');

        // Tabs & pages
        const tabMatcher    = document.getElementById('tabMatcher');
        const tabReference  = document.getElementById('tabReference');
        const matcherPage   = document.getElementById('matcherPage');
        const referencePage = document.getElementById('referencePage');
        const dmcRefStatus  = document.getElementById('dmcRefStatus');
        const dmcRefList    = document.getElementById('dmcRefList');

        // Sampling constants
        const SAMPLE_RADIUS       = 5;  // normal sampling area
        const WHITE_SAMPLE_RADIUS = 7;  // for quick white ref (older mode)

        let previewActive = false;
        let previewCanvasX = 0;
        let previewCanvasY = 0;

        let currentBestMatch = null;
        let savedMappings = [];
        let dmcInventory  = [];

        const STORAGE_KEY_MAPPINGS  = 'flossMappingsV1';
        const STORAGE_KEY_INVENTORY = 'flossInventoryV1';

        // ------- Tab logic -------
        function setActiveTab(name) {
            if (name === 'matcher') {
                matcherPage.style.display   = 'block';
                referencePage.style.display = 'none';
                tabMatcher.classList.add('tab-active');
                tabReference.classList.remove('tab-active');
            } else if (name === 'reference') {
                matcherPage.style.display   = 'none';
                referencePage.style.display = 'block';
                tabMatcher.classList.remove('tab-active');
                tabReference.classList.add('tab-active');
                renderDmcReference();
            }
        }

        tabMatcher.addEventListener('click', () => setActiveTab('matcher'));
        tabReference.addEventListener('click', () => setActiveTab('reference'));

        // ------- Local storage load/save -------
        function loadStateFromStorage() {
            try {
                const rawMappings = localStorage.getItem(STORAGE_KEY_MAPPINGS);
                if (rawMappings) {
                    savedMappings = JSON.parse(rawMappings);
                }
            } catch (e) {
                console.warn('Could not load mappings from storage', e);
            }

            try {
                const rawInv = localStorage.getItem(STORAGE_KEY_INVENTORY);
                if (rawInv) {
                    dmcInventory = JSON.parse(rawInv);
                }
            } catch (e) {
                console.warn('Could not load inventory from storage', e);
            }
        }

        function saveMappingsToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY_MAPPINGS, JSON.stringify(savedMappings));
            } catch (e) {
                console.warn('Could not save mappings', e);
            }
        }

        function saveInventoryToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY_INVENTORY, JSON.stringify(dmcInventory));
            } catch (e) {
                console.warn('Could not save inventory', e);
            }
        }

        // ------- File button -------
        fileButton.addEventListener('click', () => {
            fileInput.click();
        });

        // ------- Auto-fill inventory name from DMC palette -------
        function autoFillInventoryName() {
            // Avoid overwriting a custom name
            if (invNameInput.value && invNameInput.value !== '!') {
                return;
            }

            const brandRaw = invBrandInput.value.trim();
            const brand = brandRaw || 'DMC';

            if (brand.toUpperCase() !== 'DMC') {
                return;
            }

            const code = invCodeInput.value.trim();
            if (!code || !FLOSS_COLORS.length) {
                return;
            }

            const match = FLOSS_COLORS.find(fl => String(fl.code) === code);

            nameHintBox.style.display = 'none';

            if (match && match.name) {
                invNameInput.classList.remove('name-warning');
                invNameInput.onclick = null;
                invNameInput.value = match.name;
                return;
            }

            // No match
            invNameInput.value = '!';
            invNameInput.classList.add('name-warning');
            invNameInput.onclick = () => {
                nameHintBox.style.display = 'block';
            };
        }

        invCodeInput.addEventListener('blur', autoFillInventoryName);
        invCodeInput.addEventListener('change', autoFillInventoryName);
        invBrandInput.addEventListener('blur', autoFillInventoryName);
        invBrandInput.addEventListener('change', autoFillInventoryName);

        invNameInput.addEventListener('input', () => {
            if (invNameInput.value !== '!') {
                invNameInput.classList.remove('name-warning');
                invNameInput.onclick = null;
                nameHintBox.style.display = 'none';
            }
        });

        // ------- White reference button (legacy quick WB) -------
        setWhiteBtn.addEventListener('click', () => {
            if (!canvas.width || !canvas.height) {
                alert('Please load a photo first, then tap the white/neutral card in the image.');
                return;
            }
            calibrationMode = true;
            wbStatus.textContent = 'Calibration mode: tap a white/neutral card area in the image to set white reference.';
        });

        // ------- Rendering: mappings -------
        function renderMappings() {
            if (!savedMappings.length) {
                mappingsList.textContent = 'No pack mappings saved yet.';
                return;
            }

            const byPack = {};
            for (const m of savedMappings) {
                const key = m.packName || '(Unnamed pack)';
                if (!byPack[key]) byPack[key] = [];
                byPack[key].push(m);
            }

            let html = '';
            Object.keys(byPack).sort().forEach(packName => {
                html += `<div style="margin-top:6px; margin-bottom:4px;"><strong>${packName}</strong></div>`;
                byPack[packName].sort((a, b) => (a.slot || '').localeCompare(b.slot || ''));
                byPack[packName].forEach(m => {
                    const owned = dmcInventory.some(
                        item =>
                            String(item.code) === String(m.code) &&
                            (item.brand || 'DMC') === (m.brand || 'DMC')
                    );
                    const ownedTag = owned
                        ? `<span style="color:#16a34a; font-size:0.8rem; margin-left:6px;">(in inventory)</span>`
                        : '';
                    html += `
                        <div style="display:flex; align-items:center; gap:6px; margin-bottom:2px;">
                            <span style="font-size:0.8rem; min-width:40px;">${m.slot || '-'}</span>
                            <span style="display:inline-block; width:16px; height:16px; border-radius:3px; border:1px solid #ccc; background: rgb(${m.r}, ${m.g}, ${m.b});"></span>
                            <span style="font-size:0.85rem; flex:1 1 auto;">
                                ${m.brand || 'DMC'} ${m.code} ‚Äì ${m.name || ''}
                                ${ownedTag}
                            </span>
                            <button type="button" class="iconButton delete-mapping" data-id="${m.id}" title="Delete mapping">üóë</button>
                        </div>
                    `;
                });
            });

            mappingsList.innerHTML = html;
        }

        // ------- Rendering: inventory -------
        function renderInventory() {
            if (!dmcInventory.length) {
                inventoryList.textContent = 'No threads added yet.';
                return;
            }

            const sorted = [...dmcInventory].sort((a, b) =>
                String(a.code).localeCompare(String(b.code))
            );

            let html = '';
            sorted.forEach(item => {
                html += `
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:3px;">
                        <span>
                            <strong>${item.brand || 'DMC'} ${item.code}</strong>
                            ${item.name ? ` ‚Äì ${item.name}` : ''}
                        </span>
                        <span style="display:flex; align-items:center; gap:6px;">
                            <span style="font-size:0.8rem; color:#555;">Qty: ${item.qty ?? '-'}</span>
                            <button type="button" class="iconButton delete-inventory" data-id="${item.id}" title="Delete from inventory">üóë</button>
                        </span>
                    </div>
                `;
            });

            inventoryList.innerHTML = html;
        }

        // ------- Rendering: DMC Reference -------
        function renderDmcReference() {
            if (!FLOSS_COLORS.length) {
                dmcRefStatus.textContent = 'Palette not loaded yet. Please wait a moment or reload.';
                dmcRefList.innerHTML = '';
                return;
            }

            dmcRefStatus.textContent = `Total colours: ${FLOSS_COLORS.length}`;

            const sorted = [...FLOSS_COLORS].sort((a, b) =>
                String(a.code).localeCompare(String(b.code))
            );

            let html = '';
            sorted.forEach(c => {
                const owned = dmcInventory.some(
                    item =>
                        String(item.code) === String(c.code) &&
                        (item.brand || 'DMC') === 'DMC'
                );
                const ownedTag = owned
                    ? `<span style="margin-left:4px; font-size:0.75rem; color:#16a34a;">[Owned]</span>`
                    : '';
                html += `
                    <div style="display:flex; align-items:center; gap:8px; padding:4px 2px; border-bottom:1px solid #eee;">
                        <span style="width:18px; height:18px; border-radius:4px; border:1px solid #ccc; background: rgb(${c.r}, ${c.g}, ${c.b});"></span>
                        <span style="font-size:0.85rem; min-width:60px;"><strong>${c.code}</strong></span>
                        <span style="font-size:0.85rem; flex:1 1 auto;">${c.name || ''}</span>
                        ${ownedTag}
                    </div>
                `;
            });

            dmcRefList.innerHTML = html;
        }

        // ------- Mapping button -------
        saveMappingBtn.addEventListener('click', () => {
            saveMappingStatus.textContent = '';

            if (!currentBestMatch) {
                saveMappingStatus.textContent = 'No best match to save yet ‚Äì sample a colour first.';
                return;
            }

            const packName = packNameInput.value.trim();
            const slot     = packSlotInput.value.trim();

            if (!packName || !slot) {
                saveMappingStatus.textContent = 'Please enter both pack name and slot.';
                return;
            }

            const mapping = {
                id: Date.now(),
                packName,
                slot,
                brand: 'DMC',
                code: currentBestMatch.code,
                name: currentBestMatch.name,
                r: currentBestMatch.r,
                g: currentBestMatch.g,
                b: currentBestMatch.b
            };

            savedMappings.push(mapping);
            saveMappingsToStorage();
            renderMappings();

            saveMappingStatus.textContent = `Saved: ${packName} / ${slot} ‚Üí DMC ${mapping.code}`;
        });

        // ------- Inventory button -------
        addInventoryBtn.addEventListener('click', () => {
            inventoryStatus.textContent = '';

            const brandRaw = invBrandInput.value.trim();
            const brand = brandRaw || 'DMC';

            const code = invCodeInput.value.trim();
            const name = invNameInput.value.trim();
            const qtyRaw = invQtyInput.value.trim();

            if (!code) {
                inventoryStatus.textContent = 'Please enter a DMC code.';
                return;
            }

            const qty = qtyRaw === '' ? null : Number(qtyRaw);

            const existing = dmcInventory.find(
                item => String(item.code) === String(code) && (item.brand || 'DMC') === brand
            );

            if (existing) {
                existing.brand = brand;
                existing.name  = name || existing.name;
                if (!Number.isNaN(qty) && qty !== null) existing.qty = qty;
                inventoryStatus.textContent = `Updated inventory for ${brand} ${code}.`;
            } else {
                dmcInventory.push({
                    id: Date.now(),
                    brand,
                    code,
                    name: name || '',
                    qty: Number.isNaN(qty) ? null : qty
                });
                inventoryStatus.textContent = `Added ${brand} ${code} to inventory.`;
            }

            saveInventoryToStorage();
            renderInventory();
        });

        // ------- Delete handlers -------
        mappingsList.addEventListener('click', (e) => {
            if (!e.target.classList.contains('delete-mapping')) return;
            const id = Number(e.target.dataset.id);
            if (!id) return;
            savedMappings = savedMappings.filter(m => m.id !== id);
            saveMappingsToStorage();
            renderMappings();
        });

        inventoryList.addEventListener('click', (e) => {
            if (!e.target.classList.contains('delete-inventory')) return;
            const id = Number(e.target.dataset.id);
            if (!id) return;
            dmcInventory = dmcInventory.filter(item => item.id !== id);
            saveInventoryToStorage();
            renderInventory();
            renderDmcReference();
        });

        // ------- File input -------
        fileInput.addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                hiddenImage.onload = function () {
                    drawImageToCanvas(hiddenImage);

                    // Reset WB + calibration on new image
                    calibrationMode = false;
                    whiteRefLab = null;
                    wbStatus.textContent = 'No white reference set. For better accuracy, include a white/neutral card in your photo and set it as reference.';

                    calibPhase = null;
                    calibMeasured.grey  = null;
                    calibMeasured.white = null;
                    calibMeasured.black = null;
                    calibReady = false;
                    calibrationStatus.textContent =
                        'Not calibrated. When your reference cards arrive, tap ‚ÄúStart calibration‚Äù.';
                };
                hiddenImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        function drawImageToCanvas(img) {
            const maxDisplayWidth = 500;
            let displayWidth = img.width;
            let displayHeight = img.height;

            if (displayWidth > maxDisplayWidth) {
                const scale = maxDisplayWidth / displayWidth;
                displayWidth = maxDisplayWidth;
                displayHeight = img.height * scale;
            }

            canvas.width = displayWidth;
            canvas.height = displayHeight;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            resultsBox.style.display = 'none';
        }

        // ------- Sampling helpers -------
        function sampleAverageRGB(centerX, centerY, radius) {
            const x0 = Math.max(0, centerX - radius);
            const y0 = Math.max(0, centerY - radius);
            const x1 = Math.min(canvas.width - 1, centerX + radius);
            const y1 = Math.min(canvas.height - 1, centerY + radius);

            const width  = x1 - x0 + 1;
            const height = y1 - y0 + 1;

            const imgData = ctx.getImageData(x0, y0, width, height).data;

            let sumR = 0, sumG = 0, sumB = 0;
            const numPixels = width * height;

            for (let i = 0; i < imgData.length; i += 4) {
                sumR += imgData[i];
                sumG += imgData[i + 1];
                sumB += imgData[i + 2];
            }

            return {
                r: Math.round(sumR / numPixels),
                g: Math.round(sumG / numPixels),
                b: Math.round(sumB / numPixels)
            };
        }

        function updatePreviewAt(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();

            const scaleX = canvas.width  / rect.width;
            const scaleY = canvas.height / rect.height;

            const cx = (clientX - rect.left) * scaleX;
            const cy = (clientY - rect.top) * scaleY;

            previewCanvasX = Math.floor(cx);
            previewCanvasY = Math.floor(cy);

            const boxWidthCss  = (2 * SAMPLE_RADIUS + 1) * (rect.width  / canvas.width);
            const boxHeightCss = (2 * SAMPLE_RADIUS + 1) * (rect.height / canvas.height);

            const leftCss = (clientX - rect.left) - boxWidthCss / 2;
            const topCss  = (clientY - rect.top)  - boxHeightCss / 2;

            sampleOverlay.style.width  = boxWidthCss + 'px';
            sampleOverlay.style.height = boxHeightCss + 'px';
            sampleOverlay.style.left   = leftCss + 'px';
            sampleOverlay.style.top    = topCss + 'px';
            sampleOverlay.style.display = 'block';
        }

        function handleSampleAtCurrentPreview() {
            const radius = calibrationMode ? WHITE_SAMPLE_RADIUS : SAMPLE_RADIUS;

            const { r: rawR, g: rawG, b: rawB } = sampleAverageRGB(
                previewCanvasX,
                previewCanvasY,
                radius
            );

            // 3-card calibration flow
            if (calibPhase) {
                handleCalibrationTap(rawR, rawG, rawB);
                return;
            }

            // Legacy single white ref
            if (calibrationMode) {
                calibrationMode = false;
                setWhiteReference(rawR, rawG, rawB);
                return;
            }

            if (!FLOSS_COLORS.length) {
                alert('DMC palette not loaded yet. Please wait a moment or refresh.');
                return;
            }

            showSampleAndMatches(rawR, rawG, rawB);
        }

        // Mouse events
        canvas.addEventListener('mousedown', function (e) {
            if (!canvas.width || !canvas.height) return;
            previewActive = true;
            updatePreviewAt(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', function (e) {
            if (!previewActive) return;
            updatePreviewAt(e.clientX, e.clientY);
        });

        window.addEventListener('mouseup', function () {
            if (!previewActive) return;
            previewActive = false;
            sampleOverlay.style.display = 'none';
            handleSampleAtCurrentPreview();
        });

        // Touch events
        canvas.addEventListener('touchstart', function (e) {
            if (!canvas.width || !canvas.height) return;
            e.preventDefault();
            const t = e.touches[0];
            previewActive = true;
            updatePreviewAt(t.clientX, t.clientY);
        });

        canvas.addEventListener('touchmove', function (e) {
            if (!previewActive) return;
            e.preventDefault();
            const t = e.touches[0];
            updatePreviewAt(t.clientX, t.clientY);
        });

        canvas.addEventListener('touchend', function () {
            if (!previewActive) return;
            previewActive = false;
            sampleOverlay.style.display = 'none';
            handleSampleAtCurrentPreview();
        });

        canvas.addEventListener('touchcancel', function () {
            previewActive = false;
            sampleOverlay.style.display = 'none';
        });

        // ------- White reference in Lab (legacy) -------
        function setWhiteReference(r, g, b) {
            const lab = rgbToLab(r, g, b);

            if (lab.L < 50) {
                alert('That area is too dark to be a white reference. Please choose a brighter white/neutral area.');
                wbStatus.textContent = 'White reference not set ‚Äì chosen area was too dark.';
                return;
            }

            whiteRefLab = lab;
            const refHex = rgbToHex(r, g, b);
            wbStatus.innerHTML = `
                White reference set at RGB (${r}, ${g}, ${b}) | Hex ${refHex}.
                Matching will compensate for colour cast based on this reference.
            `;
        }

        // ------- 3-card calibration helpers -------
        function handleCalibrationTap(r, g, b) {
            if (calibPhase === 'grey') {
                calibMeasured.grey = { r, g, b };
                calibPhase = 'white';
                calibrationStatus.textContent =
                    'Step 2/3: Tap the white card in the image.';
                return;
            }

            if (calibPhase === 'white') {
                calibMeasured.white = { r, g, b };
                calibPhase = 'black';
                calibrationStatus.textContent =
                    'Step 3/3: Tap the black card in the image.';
                return;
            }

            if (calibPhase === 'black') {
                calibMeasured.black = { r, g, b };
                calibPhase = null;
                buildCalibrationModel();
                return;
            }
        }

        function clamp255(v) {
            return Math.min(255, Math.max(0, Math.round(v)));
        }

        function applyChannelCalibration(value, mB, mG, mW, tB, tG, tW) {
            if (
                mB == null || mG == null || mW == null ||
                mB === mG || mG === mW
            ) {
                return value;
            }

            if (value <= mG) {
                const slope = (tG - tB) / (mG - mB);
                const intercept = tB - slope * mB;
                return clamp255(slope * value + intercept);
            } else {
                const slope = (tW - tG) / (mW - mG);
                const intercept = tG - slope * mG;
                return clamp255(slope * value + intercept);
            }
        }

        function buildCalibrationModel() {
            const mGrey  = calibMeasured.grey;
            const mWhite = calibMeasured.white;
            const mBlack = calibMeasured.black;

            if (!mGrey || !mWhite || !mBlack) {
                calibrationStatus.textContent =
                    'Calibration failed: please tap all three cards (grey, white, black).';
                calibReady = false;
                return;
            }

            calibReady = true;
            calibrationStatus.textContent =
                'Calibration ready. All future samples from this photo will use 3-card correction.';
        }

        startCalibBtn.addEventListener('click', () => {
            if (!canvas.width || !canvas.height) {
                alert('Load a photo with your grey, white, and black cards first.');
                return;
            }
            calibPhase = 'grey';
            calibMeasured.grey  = null;
            calibMeasured.white = null;
            calibMeasured.black = null;
            calibReady = false;
            calibrationStatus.textContent =
                'Step 1/3: Tap the 18% grey card in the image (avoid shadows).';
        });

        resetCalibBtn.addEventListener('click', () => {
            calibPhase = null;
            calibMeasured.grey  = null;
            calibMeasured.white = null;
            calibMeasured.black = null;
            calibReady = false;
            calibrationStatus.textContent =
                'Not calibrated. When your reference cards arrive, tap ‚ÄúStart calibration‚Äù.';
        });

        // ------- Show sample + matches -------
        function showSampleAndMatches(r, g, b) {
            // Apply 3-card calibration if ready
            if (calibReady) {
                const mG = calibMeasured.grey;
                const mW = calibMeasured.white;
                const mB = calibMeasured.black;

                const cR = applyChannelCalibration(
                    r,
                    mB.r, mG.r, mW.r,
                    CARD_TARGETS.black.r, CARD_TARGETS.grey.r, CARD_TARGETS.white.r
                );
                const cG = applyChannelCalibration(
                    g,
                    mB.g, mG.g, mW.g,
                    CARD_TARGETS.black.g, CARD_TARGETS.grey.g, CARD_TARGETS.white.g
                );
                const cB = applyChannelCalibration(
                    b,
                    mB.b, mG.b, mW.b,
                    CARD_TARGETS.black.b, CARD_TARGETS.grey.b, CARD_TARGETS.white.b
                );

                r = cR;
                g = cG;
                b = cB;
            }

            const hex = rgbToHex(r, g, b);
            sampleSwatch.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            rgbText.textContent = `RGB (corrected): (${r}, ${g}, ${b})  |  Hex: ${hex}`;

            const count = parseInt(matchCountSel.value, 10) || 5;

            const sampleLabRaw = rgbToLab(r, g, b);
            let sampleLabForMatching = sampleLabRaw;

            // Optional extra Lab-level WB tweak
            if (whiteRefLab) {
                sampleLabForMatching = {
                    L: sampleLabRaw.L,
                    a: sampleLabRaw.a - whiteRefLab.a,
                    b: sampleLabRaw.b - whiteRefLab.b
                };
            }

            const topMatches = findClosestFlosses(sampleLabForMatching, count);

            if (!topMatches.length) {
                bestMatchDiv.textContent = 'No matches found.';
                matchesList.innerHTML = '';
                resultsBox.style.display = 'block';
                currentBestMatch = null;
                return;
            }

            const best = topMatches[0];
            currentBestMatch = best;

            const bestLabel = qualityLabel(best.distance);
            const ownedBest = dmcInventory.some(
                item =>
                    String(item.code) === String(best.code) &&
                    (item.brand || 'DMC') === (best.brand || 'DMC')
            );
            const ownedBadge = ownedBest
                ? `<span style="margin-left:6px; font-size:0.8rem; color:#16a34a;">(in your inventory)</span>`
                : '';

            bestMatchDiv.innerHTML = `
                <div class="match-item">
                    <span class="match-swatch" style="background-color: rgb(${best.r}, ${best.g}, ${best.b});"></span>
                    <span class="match-code">DMC ${best.code} ‚Äì ${best.name}</span>
                    ${ownedBadge}<br>
                    <span>ŒîE2000: ${best.distance.toFixed(2)} </span>
                    <span class="match-label">(${bestLabel})</span>
                </div>
            `;

            let listHtml = '';
            for (let i = 1; i < topMatches.length; i++) {
                const m = topMatches[i];
                const label = qualityLabel(m.distance);
                const owned = dmcInventory.some(
                    item =>
                        String(item.code) === String(m.code) &&
                        (item.brand || 'DMC') === (m.brand || 'DMC')
                );
                const ownedTag = owned
                    ? `<span style="margin-left:4px; font-size:0.75rem; color:#16a34a;">(owned)</span>`
                    : '';

                listHtml += `
                    <div class="match-item">
                        <span class="match-swatch" style="background-color: rgb(${m.r}, ${m.g}, ${m.b});"></span>
                        <span class="match-code">DMC ${m.code} ‚Äì ${m.name}</span>
                        ${ownedTag}
                        <span> | ŒîE2000: ${m.distance.toFixed(2)}</span>
                        <span class="match-label"> (${label})</span>
                    </div>
                `;
            }
            matchesList.innerHTML = listHtml;

            resultsBox.style.display = 'block';
        }

        // ------- Matching helpers -------
        function findClosestFlosses(sampleLab, count) {
            const withDistances = FLOSS_COLORS.map(fl => ({
                ...fl,
                distance: deltaE2000(sampleLab, fl.lab)
            }));
            withDistances.sort((a, b) => a.distance - b.distance);
            return withDistances.slice(0, Math.min(count, withDistances.length));
        }

        function qualityLabel(dE) {
            if (dE < 1)   return 'Perfect / indistinguishable';
            if (dE < 2)   return 'Excellent match';
            if (dE < 5)   return 'Very good match';
            if (dE < 8)   return 'Good / usable match';
            if (dE < 15)  return 'Approximate match';
            return 'Rough / far off';
        }

        // ------- Colour conversions -------
        function rgbToLab(r, g, b) {
            let R = r / 255;
            let G = g / 255;
            let B = b / 255;

            R = R <= 0.04045 ? R / 12.92 : Math.pow((R + 0.055) / 1.055, 2.4);
            G = G <= 0.04045 ? G / 12.92 : Math.pow((G + 0.055) / 1.055, 2.4);
            B = B <= 0.04045 ? B / 12.92 : Math.pow((B + 0.055) / 1.055, 2.4);

            let X = R * 0.4124 + G * 0.3576 + B * 0.1805;
            let Y = R * 0.2126 + G * 0.7152 + B * 0.0722;
            let Z = R * 0.0193 + G * 0.1192 + B * 0.9505;

            const refX = 0.95047;
            const refY = 1.00000;
            const refZ = 1.08883;

            X /= refX;
            Y /= refY;
            Z /= refZ;

            X = xyzToLabHelper(X);
            Y = xyzToLabHelper(Y);
            Z = xyzToLabHelper(Z);

            const L = 116 * Y - 16;
            const a = 500 * (X - Y);
            const bVal = 200 * (Y - Z);

            return { L, a, b: bVal };
        }

        function xyzToLabHelper(t) {
            const delta = 6 / 29;
            return t > Math.pow(delta, 3)
                ? Math.cbrt(t)
                : (t / (3 * Math.pow(delta, 2))) + (4 / 29);
        }

        function deltaE2000(lab1, lab2) {
            const L1 = lab1.L;
            const a1 = lab1.a;
            const b1 = lab1.b;
            const L2 = lab2.L;
            const a2 = lab2.a;
            const b2 = lab2.b;

            const kL = 1;
            const kC = 1;
            const kH = 1;

            const C1 = Math.sqrt(a1 * a1 + b1 * b1);
            const C2 = Math.sqrt(a2 * a2 + b2 * b2);
            const Cbar = (C1 + C2) / 2.0;

            const Cbar7 = Math.pow(Cbar, 7);
            const G = 0.5 * (1 - Math.sqrt(Cbar7 / (Cbar7 + Math.pow(25, 7))));

            const a1Prime = (1 + G) * a1;
            const a2Prime = (1 + G) * a2;

            const C1Prime = Math.sqrt(a1Prime * a1Prime + b1 * b1);
            const C2Prime = Math.sqrt(a2Prime * a2Prime + b2 * b2);
            const CbarPrime = (C1Prime + C2Prime) / 2.0;

            const h1Prime = calcHuePrime(b1, a1Prime);
            const h2Prime = calcHuePrime(b2, a2Prime);

            let deltahPrime;
            const diffh = h2Prime - h1Prime;
            if (C1Prime * C2Prime === 0) {
                deltahPrime = 0;
            } else if (Math.abs(diffh) <= 180) {
                deltahPrime = diffh;
            } else if (diffh > 180) {
                deltahPrime = diffh - 360;
            } else {
                deltahPrime = diffh + 360;
            }

            const deltaLPrime = L2 - L1;
            const deltaCPrime = C2Prime - C1Prime;
            const deltaHPrime = 2 * Math.sqrt(C1Prime * C2Prime) * Math.sin(deg2rad(deltahPrime / 2));

            let HbarPrime;
            if (C1Prime * C2Prime === 0) {
                HbarPrime = h1Prime + h2Prime;
            } else if (Math.abs(h1Prime - h2Prime) <= 180) {
                HbarPrime = (h1Prime + h2Prime) / 2;
            } else if ((h1Prime + h2Prime) < 360) {
                HbarPrime = (h1Prime + h2Prime + 360) / 2;
            } else {
                HbarPrime = (h1Prime + h2Prime - 360) / 2;
            }

            const T =
                1 -
                0.17 * Math.cos(deg2rad(HbarPrime - 30)) +
                0.24 * Math.cos(deg2rad(2 * HbarPrime)) +
                0.32 * Math.cos(deg2rad(3 * HbarPrime + 6)) -
                0.20 * Math.cos(deg2rad(4 * HbarPrime - 63));

            const deltaTheta =
                30 * Math.exp(-((HbarPrime - 275) / 25) * ((HbarPrime - 275) / 25));
            const R_C = 2 * Math.sqrt(Math.pow(CbarPrime, 7) / (Math.pow(CbarPrime, 7) + Math.pow(25, 7)));
            const Lbar = (L1 + L2) / 2;
            const S_L = 1 + ((0.015 * (Lbar - 50) * (Lbar - 50)) / Math.sqrt(20 + (Lbar - 50) * (Lbar - 50)));
            const S_C = 1 + 0.045 * CbarPrime;
            const S_H = 1 + 0.015 * CbarPrime * T;
            const R_T = -Math.sin(deg2rad(2 * deltaTheta)) * R_C;

            const dE = Math.sqrt(
                Math.pow(deltaLPrime / (kL * S_L), 2) +
                Math.pow(deltaCPrime / (kC * S_C), 2) +
                Math.pow(deltaHPrime / (kH * S_H), 2) +
                R_T * (deltaCPrime / (kC * S_C)) * (deltaHPrime / (kH * S_H))
            );

            return dE;
        }

        function calcHuePrime(b, aPrime) {
            if (aPrime === 0 && b === 0) return 0;
            const hue = rad2deg(Math.atan2(b, aPrime));
            return hue >= 0 ? hue : hue + 360;
        }

        function deg2rad(deg) {
            return (deg * Math.PI) / 180;
        }

        function rad2deg(rad) {
            return (rad * 180) / Math.PI;
        }

        function rgbToHex(r, g, b) {
            return "#" + [r, g, b].map(function (x) {
                const hex = x.toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join("");
        }

        // ------- Palette load -------
        fetch('dmc_palette.json?v=' + APP_VERSION)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Could not load dmc_palette.json');
                }
                return response.json();
            })
            .then(data => {
                FLOSS_COLORS = data.map(c => ({
                    ...c,
                    lab: rgbToLab(c.r, c.g, c.b)
                }));
                console.log('Loaded DMC colours:', FLOSS_COLORS.length);
                renderDmcReference();
            })
            .catch(err => {
                console.error(err);
                alert('Could not load DMC palette. Check that dmc_palette.json is in the same folder as index.html.');
            });

        // ------- Init -------
        loadStateFromStorage();
        renderMappings();
        renderInventory();
        setActiveTab('matcher');
    </script>
</body>
</html>